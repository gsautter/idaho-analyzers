<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!-- edited with XMLSpy v2005 U (http://www.xmlspy.com) by Guido Sautter (Institut für Programmstrukturen und Datenorganisation (IPD), Universität Karlsruhe) -->
<!--W3C Schema generated by XMLSpy v2005 U (http://www.xmlspy.com)-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
	<xs:element name="omniFat">
		<xs:annotation>
			<xs:documentation>Root node of an OmniFAT instance descriptor.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:annotation>
					<xs:documentation>Content - rank groups have to be in descending order.</xs:documentation>
				</xs:annotation>
				<xs:element name="description" type="xs:string">
					<xs:annotation>
						<xs:documentation>Description of the OmniFAT instance. This field is intended for documenting the concrete OmniFAT instance, in particular for explaining what sort of documents it is optimized for.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="fuzzyMatch" minOccurs="0">
					<xs:annotation>
						<xs:documentation>Threshold for epithet fuzzy match. If set to a value grater than zero, uncertain epithets will be compared to document positive epithets of the same rank group, and are promoted to document positive if the edit distance is less than or equal to the specified threshold. Handle with care.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attribute name="threshold" type="xs:integer" use="required">
							<xs:annotation>
								<xs:documentation>Actual threshold value.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<xs:element name="abbreviationLengthInLetters" minOccurs="0">
					<xs:annotation>
						<xs:documentation>Specify minimum and maximum nunber of letters for an abbreviated epithet. Succeeding dot are not counted.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attribute name="min" type="xs:integer" use="optional" default="1">
							<xs:annotation>
								<xs:documentation>The minimum number of letters in an abbreviated epithet, default is 1.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute name="max" type="xs:integer" use="optional" default="2">
							<xs:annotation>
								<xs:documentation>The maximum number of letters in an abbreviated epithet, default is 2.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>Configuration elements that may appear in any order to allow for listing them in groups specific to individual sorts of documents.</xs:documentation>
					</xs:annotation>
					<xs:element ref="dictionary" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element ref="pattern" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="stemmingRule" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Rule for stemming flected words for dictionary lookups. This is used to filter all possible epithets, except those from trusted positive dictionaries. The content of the element is a list of endings that can be substituted for the match ending. Start this list with a separator to indicate that the empty string should be part of the list.</xs:documentation>
						</xs:annotation>
						<xs:complexType mixed="true">
							<xs:complexContent mixed="true">
								<xs:extension base="internalList">
									<xs:attribute name="matchEnding" type="xs:string" use="required">
										<xs:annotation>
											<xs:documentation>Suffix a word has to end with in order for the stemming rule to apply.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:extension>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
					<xs:element name="intraEpithetPunctuation" type="internalList" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>List of characters or words that can appear inside an epithet, e.g. between the actual epithet string and the epithet's author. This is often specific to the layout and formatting guidelines of individual journals.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="interEpithetPunctuation" type="internalList" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>List of characters or words that can appear between the individual epithets of a taxon name. This is often specific to the layout and formatting guidelines of individual journals.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="newEpithetLabels" type="internalList" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>List of words or phrases that make up the label of a new epithet (e.g. 'new species') together with a label for the actual rank. To make up the label 'new species', for instance, this list has to contain 'new', and 'species' has to be listed as a label in the respective rank element.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
				<xs:element ref="rankGroup" maxOccurs="unbounded"/>
				<xs:element name="authors">
					<xs:annotation>
						<xs:documentation>Container for epithet author name recognition data.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:choice maxOccurs="unbounded">
							<xs:element name="dictionary">
								<xs:annotation>
									<xs:documentation>Dictionary of author names.</xs:documentation>
								</xs:annotation>
								<xs:complexType>
									<xs:attribute name="ref" type="xs:string" use="required">
										<xs:annotation>
											<xs:documentation>Name of the file to load the dictionary from.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute name="trusted" type="xs:boolean" use="optional" default="false">
										<xs:annotation>
											<xs:documentation>Indicator whether the dictionary is clean and the words and phrases contained in it are always author names. Handle with care.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:complexType>
							</xs:element>
							<xs:element name="pattern">
								<xs:annotation>
									<xs:documentation>Pattern matching likely author names, or parts of them.</xs:documentation>
								</xs:annotation>
								<xs:complexType>
									<xs:attribute name="string" type="xs:string" use="required">
										<xs:annotation>
											<xs:documentation>Actual regular expression pattern, or name of the file to load the pattern from.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute name="type" use="optional" default="positive">
										<xs:annotation>
											<xs:documentation>Indicator whether the pattern matches whole author names (positive), parts of author names (part), or phrases that are definitely not author names (negative).</xs:documentation>
										</xs:annotation>
										<xs:simpleType>
											<xs:restriction base="xs:string">
												<xs:enumeration value="positive"/>
												<xs:enumeration value="part"/>
												<xs:enumeration value="negative"/>
											</xs:restriction>
										</xs:simpleType>
									</xs:attribute>
									<xs:attribute name="isRef" type="xs:boolean" use="optional" default="false">
										<xs:annotation>
											<xs:documentation>If set to true, the value of the string attribute is interpretetd as a file name to  load the pattern from. Otherwise, the value of the string attribute is interpreted as an actual pattern.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:complexType>
							</xs:element>
							<xs:element name="nameStopWords" type="internalList">
								<xs:annotation>
									<xs:documentation>List of stop words that appear within author names.</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="nameListSeparators" type="internalList">
								<xs:annotation>
									<xs:documentation>List of characters or words that can act as separators in lists of author names, between all but the second-to-last and the last author in a list.</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="nameListEndSeparators" type="internalList">
								<xs:annotation>
									<xs:documentation>List of characters or words that can act as separators in lists of author names, between all authors in a list, including the second-to-last and the last author.</xs:documentation>
								</xs:annotation>
							</xs:element>
						</xs:choice>
					</xs:complexType>
				</xs:element>
				<xs:element name="rules">
					<xs:annotation>
						<xs:documentation>Container for the rule sets.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="ruleSet" minOccurs="0" maxOccurs="unbounded">
								<xs:annotation>
									<xs:documentation>A set of data rules. Each set of rules is applied over and over again until it yields no more new assignments. Only then, execution switches to the next rule set.</xs:documentation>
								</xs:annotation>
								<xs:complexType>
									<xs:sequence>
										<xs:element name="rule" maxOccurs="unbounded">
											<xs:annotation>
												<xs:documentation>An individula data rule.</xs:documentation>
											</xs:annotation>
											<xs:complexType>
												<xs:attribute name="match" type="xs:string" use="required">
													<xs:annotation>
														<xs:documentation>The pattern of epithet states a candidate has to match so the rule applies.</xs:documentation>
													</xs:annotation>
												</xs:attribute>
												<xs:attribute name="action" use="required">
													<xs:annotation>
														<xs:documentation>The action to take if the rule applies to a candidate - promote, feedback, or remove.</xs:documentation>
													</xs:annotation>
													<xs:simpleType>
														<xs:restriction base="xs:string">
															<xs:enumeration value="promote"/>
															<xs:enumeration value="remove"/>
															<xs:enumeration value="feedback"/>
														</xs:restriction>
													</xs:simpleType>
												</xs:attribute>
												<xs:attribute name="removeNested" type="xs:boolean" use="optional" default="false">
													<xs:annotation>
														<xs:documentation>If set to true, all candidates nested in a matching candidate are removed. This always happens if the action is promote, and never if the action is remove, so the setting has an effect only if the action is feedback.</xs:documentation>
													</xs:annotation>
												</xs:attribute>
												<xs:attribute name="likelyMatch" type="xs:boolean" use="optional" default="false">
													<xs:annotation>
														<xs:documentation>Only has an effect if the action is feedback. If set to true, the state of a feedback candidate generated by the rule is set to likely. Otherwise, the state is set to uncertain.</xs:documentation>
													</xs:annotation>
												</xs:attribute>
											</xs:complexType>
										</xs:element>
									</xs:sequence>
									<xs:attribute name="maxRounds" type="xs:integer" use="optional" default="0">
										<xs:annotation>
											<xs:documentation>The maximum number of rounds to apply the data rules contained in this rule set. The default is 0, indicating the rules to be applied as long as any changes occur.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute name="cleanupAfter" type="xs:boolean" use="optional" default="true">
							<xs:annotation>
								<xs:documentation>Remove remaining internal candidates after data rule application? By default, this attribute is true. However, it can be beneficial to keep the remaining internal candidates if there are other means around to handle them.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:complexType name="internalList" mixed="true">
		<xs:attribute name="separator" type="xs:string" use="optional" default=";">
			<xs:annotation>
				<xs:documentation>Separator of individual list entries, default is a semicolon.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:element name="dictionary">
		<xs:annotation>
			<xs:documentation>Dictionary of epithets of a rank or rank group, or of negatives.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="type" use="required">
				<xs:annotation>
					<xs:documentation>Indicator for how to use a dictionary - as a list of epithets (positive), a list of common language words (negative), or a list of stop words (stopWord).</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="positive"/>
						<xs:enumeration value="negative"/>
						<xs:enumeration value="stopWord"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="ref" type="xs:string" use="required">
				<xs:annotation>
					<xs:documentation>Name of the file to load the dictionary from.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="trusted" type="xs:boolean" use="optional" default="false">
				<xs:annotation>
					<xs:documentation>Indicator whether the dictionary is clean and the words and phrases contained in it are always epithet names. Has an effect only for positive dictionaries. Handle with care.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="suffixDiffThreshold" type="xs:integer" use="optional" default="0">
				<xs:annotation>
					<xs:documentation>Minimum length of suffixes to use for suffix diff filtering of epithets. Has an effect only for negative dictionaries.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="label">
		<xs:annotation>
			<xs:documentation>An individual label for epithets of the rank.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="value" type="xs:string" use="required">
				<xs:annotation>
					<xs:documentation>Actual label string.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="labels" type="internalList">
		<xs:annotation>
			<xs:documentation>List of labels for epithets of the rank.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="pattern">
		<xs:annotation>
			<xs:documentation>Regular expression pattern for identifying or filtering epithets of a rank or rank group.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="string" type="xs:string" use="required">
				<xs:annotation>
					<xs:documentation>Actual regular expression pattern, or name of the file to load the pattern from.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="type" use="required">
				<xs:annotation>
					<xs:documentation>Indicator whether matches of the pattern are sure positive epithets of a rank or rank group (precision), likely epithets of a rank or rank group (recall), or phrases that are definitely not epithets of a rank or rank group (negative).</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="negative"/>
						<xs:enumeration value="precision"/>
						<xs:enumeration value="recall"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="isRef" type="xs:boolean" use="optional" default="false">
				<xs:annotation>
					<xs:documentation>If set to true, the value of the string attribute is interpretetd as a file name to  load the pattern from. Otherwise, the value of the string attribute is interpreted as an actual pattern.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="rankGroup">
		<xs:annotation>
			<xs:documentation>Group of taxonomic ranks, having similar spelling and capitalization characteristics.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:annotation>
					<xs:documentation>Content of a rank group - ranks have to be in descending order.</xs:documentation>
				</xs:annotation>
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ref="dictionary"/>
					<xs:element ref="pattern"/>
				</xs:choice>
				<xs:element ref="rank" maxOccurs="unbounded"/>
			</xs:sequence>
			<xs:attribute name="name" type="xs:string" use="required">
				<xs:annotation>
					<xs:documentation>Name of the rank group.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="repeatedEpithets" type="xs:boolean" use="optional" default="false">
				<xs:annotation>
					<xs:documentation>Does word repetition in this rank group indicate a sure positive, like 'sapiens' in 'Homo sapiens sapiens'?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="doSuffixDiff" type="xs:boolean" use="optional" default="false">
				<xs:annotation>
					<xs:documentation>Do suffix diff filtering of epithets matched by recall patterns of the rank group or an individual rank. If set to true, uncertain epithets will be excluded if thy have an ending that is highly characteristic for a negative dictionary in comparison to the positive dictionaries of the rank group.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="learningMode" use="optional" default="teach">
				<xs:annotation>
					<xs:documentation>Way the OmniFAT instance should learn new epithets of the rank group - automatically (auto), on external invocation of the teaching methods (teach), or never (off).</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="auto"/>
						<xs:enumeration value="teach"/>
						<xs:enumeration value="off"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="capitalized" use="required">
				<xs:annotation>
					<xs:documentation>Indicator for whether epithets of the rank group are capitalized - always, sometimes, or never.</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="always"/>
						<xs:enumeration value="mixed"/>
						<xs:enumeration value="never"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="rank">
		<xs:annotation>
			<xs:documentation>A specific taxonomic rank, with its own characteristic spelling or epithet labeling.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element ref="label" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="labels" minOccurs="0"/>
				<xs:element ref="pattern" minOccurs="0"/>
				<xs:element ref="dictionary" minOccurs="0"/>
			</xs:choice>
			<xs:attribute name="required" type="xs:boolean" use="optional" default="false">
				<xs:annotation>
					<xs:documentation>Indicator for whether a taxon name must have an epithet of this rank if it has epithets above and below the rank.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="name" type="xs:string" use="required">
				<xs:annotation>
					<xs:documentation>Name of the rank. Must be unique within the scope of an OmniFAT instance, i.e., across all rank groups.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="epithetDisplayPattern" type="xs:string" use="optional" default="@epithet">
				<xs:annotation>
					<xs:documentation>Template for displaying an epithet of the rank in a normalized representation of a taxon name. Use '@epithet' to represent the spot where the actual epithet should be inserted. Default is '@epithet', indicating the epithet value should be used as is.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="labeled" use="optional" default="sometimes">
				<xs:annotation>
					<xs:documentation>Indicator whether epithets of the rank are labeled if they appear within a taxon name - always, sometimes, or never.</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="always"/>
						<xs:enumeration value="never"/>
						<xs:enumeration value="sometimes"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="probability" use="optional" default="5">
				<xs:annotation>
					<xs:documentation>Probability of an epithet of the rank to be given in a taxon name, on a scale from 0 to 10, inclusive. Hepls with resolving ambiguous rank assignments, prefering ranks with a higher probability. Default is 5.</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:integer">
						<xs:minInclusive value="0"/>
						<xs:maxInclusive value="10"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
</xs:schema>
